# from __future__ import annotations  ->  no son, it's Python 3.6 :(
import re
import collections
import numpy as np

from typing import Dict, List, Tuple, Iterable, Any, Union
from utils import relabel

"""
The parsing of files originating from the manual segmentation process
comes with a lot of metadata processing.
"""


class TaggedData:
    """
    Minimal wrapper class for numpy.ndarrays living in the data attribute
    and heterogenous metadata (mostly dictionaries) living in the
    metadata attribute.
    """
    long_repr = False

    def __init__(self, data: np.ndarray, metadata: Any) -> None:
        self.data = data
        self.metadata = metadata
    

    def __repr__(self) -> str:
        """
        Provide a nice instance representation string.
        The length/degree of detail can be switched via the class variable
        `long_repr`.
        """
        if self.long_repr:
            attr_repr = 'arr_shape={}, arr_dtype={}, metadata={}'.format(self.data.shape,
                                                                         self.data.dtype,
                                                                         self.metadata)
        else:
            attr_repr = 'arr_shape={}, arr_dtype={}, metadata_type={}'.format(self.data.shape,
                                                                              self.data.dtype,
                                                                              type(self.metadata))
        repr_str = '{}({})'.format(
            self.TaggedData.__name__,
            attr_repr
        )
        return repr_str


class RawData(TaggedData):
    """
    Tagged CT raw data.
    Usually just a 3D scalar NumPy array (data) and an OrderedDict (metadata).
    """
    pass


class SegmentationData(TaggedData):
    """
    Tagged segmentation data.

    The incoming metadata is expected to be an collections.OrderedDict that holds fields
    that adhere to the 3DSlicer segmentation node specification:
    -> https://apidocs.slicer.org/master/classvtkMRMLSegmentationStorageNode.html#details

    """

    def __init__(self, data: np.ndarray, metadata: Any) -> None:
        super(SegmentationData, self).__init__(data, metadata)

        # creates the per-segment metadata information as `SegmentInfo` instances
        # the attribute is layed out as a dict with the label_value of the
        # segment as the key and the `SegmentInfo` as the value
        self.infos = {
            si.label_value : si for si in SegmentInfo.from_header(metadata)
        }
        # TODO: this is sloooow due to numpy.unique!
        # self._check_consistency()
    

    def _check_consistency(self) -> None:
        """Run some sanity checks that metadata and numerical data are consistent"""
        lbl_vals_from_metadata = set(self.infos.keys())
        # background with label_value 0 is generally not included in metadata dict
        lbl_vals_from_metadata.add(0)
        lbl_vals_from_data = set(np.unique(self.data))
        # TODO: check if numerical datatype shenanigans ruin the day
        # i.e. something along the lines of 1.0 != 1
        symm_diff = lbl_vals_from_data ^ lbl_vals_from_metadata

        if len(symm_diff) != 0:
            msg = (f'Label mismatch between data and metadata! Expected vanishing '
                   f'symmetric difference but got: {symm_diff}')
            raise ValueError(msg)
    

    def __getitem__(self, label_value: int) -> 'SegmentInfo':
        """
        Directly retrieve the segment label information (as a SegmentInfo object)
        via its integer label value that is used as a index here.
        """
        return self.infos[label_value]

    
    def __repr__(self) -> str:
        arr_info_str = 'arr_shape={}, arr_dtype={}'.format(self.data.shape,
                                                         self.data.dtype)
        segment_info = []
        for seginfo_elem in self.infos.values():
            segment_info.append(
                '({}, {})'.format(seginfo_elem.name, seginfo_elem.label_value)
            )        
        seg_info_str = 'segment_count={}, segments=[{}]'.format(
            len(segment_info), ', '.join(segment_info)
        )
        repr_str = '{}({})'.format(self.__class__.__name__,
                                   ', '.join((arr_info_str, seg_info_str)))
        return repr_str




class SegmentInfo:
    """
    A dataclass-like object to store the metadata information belonging to
    a segment in a 3D-Slicer generated segmentation.
    """
    slicer_to_internal_alias = {
        'Color' : 'color',
        'ColorAutoGenerated' : 'color_autogenerated',
        'Extent' : 'extent',
        'ID' : 'ID',
        'LabelValue' : 'label_value',
        'Layer' : 'layer',
        'Name' : 'name',
        'NameAutoGenerated' : 'name_autogenerated',
        'Tags' : 'tags'
    }
    # reversed mapping
    internal_to_slicer_alias =  {
        value : key for key, value in slicer_to_internal_alias.items()
    }
    # fields for the __repr__ dunder method
    repr_field_names = ['name', 'label_value', 'color', 'ID']

    def __init__(self, name, color, ID, label_value,
                 extent, color_autogenerated, layer,
                 name_autogenerated, tags) -> None:
        
        self.name = name
        self.color = color
        self.ID = ID
        self.label_value = label_value
        self.extent = extent
        self.color_autogenerated = color_autogenerated
        self.layer = layer
        self.name_autogenerated = name_autogenerated
        self.tags = tags

    
    def __repr__(self) -> str:
        # string repr sequence of selected attributes
        attr_kv_seq = ', '.join(
            ('{}={}'.format(name, getattr(self, name))
            for name in self.repr_field_names)
        )
        repr_str = '{}({})'.format(
            self.__class__.__name__,
            attr_kv_seq
        )
        return repr_str

    
    def __eq__(self, other) -> bool:
        """Dunder comparison method."""
        # TODO: We got to think about the case: When do SegmentInfo
        # objects represent the same thing? When label values are identical?
        # Or when additional fields are equal?
        if not isinstance(other, SegmentInfo):
            return NotImplemented
        else:
            return self.ID == other.ID


    def to_dict(self, keystyle='internal') -> Dict:
        """
        Turn/devolve the object into a dictionary (Python primitive).
        """
        if keystyle not in ('internal', 'slicer'):
            msg = f'Unrecognized keystyle: {keystyle}'
            raise ValueError(msg)
        
        if keystyle == 'internal':
            obj_dict = {
                key : getattr(self, key)
                for key in self.internal_to_slicer_alias.keys()
            }
        else:
            obj_dict = {
                key : getattr(self, value)
                for key, value in self.slicer_to_internal_alias.items()
            }
        return obj_dict


    @property
    def color(self) -> Tuple[float]:
        return self._color
    

    @color.setter
    def color(self, c: Iterable) -> None:
        """
        Set the segment color. Must be a RGB tuple (r, g, b)
        The new color specification may be a space-separated string
        whose parts are required to be float-castable.
        Otherwise a tree tuple is required.
        """
        if isinstance(c, str):
            # try RGB interpretation from string
            c = c.split(' ')
        
        c_checked = []
        for val in c:
            val = float(val)
            assert val >= 0 and val <= 1, 'RGB value must be in closed interval [0, 1]'
            c_checked.append(val)
        
        self._color = tuple(c_checked)


    @property
    def label_value(self) -> int:
        return self._label_value
    

    @label_value.setter
    def label_value(self, new_label_value: int) -> None:
        """
        Managed attribute setter for label_value, which
        is expected to be an integer.
        """
        if not isinstance(new_label_value, int):
            new_label_value = int(new_label_value)
        
        self._label_value = new_label_value



    @classmethod
    def from_header(cls,
                    header_data: collections.OrderedDict) -> List['SegmentInfo']:
        """
        Directly create the exhaustive list of SegmentInfo instances from
        the header data
        """
        segment_prefix = 'Segment'
        pattern = re.compile(pattern=segment_prefix + '\d')
        segment_attrs = {}
        # exhaustive search over the full header dictionary
        for key, value in header_data.items():
            # only concern ourselves segment key - value pairs
            if pattern.match(key):
                # 3D Slicer key naming scheme: (SegmentN_attrname, attrval)
                segment_id, attr_alias = key.split('_')
                # translate the 3D Slicer attr alias to our preferred internal name
                attr_name = cls.slicer_to_internal_alias[attr_alias]
                # insert into the dictionary
                try:
                    segment_attrs[segment_id]
                except KeyError:
                    # not encountered this segment up until now
                    # make a new subdictionary
                    segment_attrs[segment_id] = {}
                
                segment_attrs[segment_id][attr_name] = value
        
        return [cls(**kwargs) for kwargs in segment_attrs.values()]




if __name__ == '__main__':

    import pathlib
    from reader import MRBFile

    fpath = pathlib.Path('C:/Users/Jannik/Desktop/mrbreader/tests/assets/testmrb_multiseg.mrb')

    mrb = MRBFile(fpath)

    data, header = mrb.get_segmentations()[0]

    sis = SegmentInfo.from_header(header)
    print(sis[1].color)
    for s in sis:
        print(s)


    segdat = SegmentationData(data, header)


    rlb = relabel(segdat.data, 0, 1234)

    print(np.unique(rlb))



    