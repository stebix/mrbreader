import re
import collections
from typing import Union, Dict, List, Iterable, Tuple



class SegmentInfo:
    """
    A dataclass-like object to store the metadata information belonging to
    a segment in a 3D-Slicer generated segmentation.
    We use managed attributes to enforce certain restrictions on attribute values.
    """
    slicer_to_internal_alias = {
        'Color' : 'color',
        'ColorAutoGenerated' : 'color_autogenerated',
        'Extent' : 'extent',
        'ID' : 'ID',
        'LabelValue' : 'label_value',
        'Layer' : 'layer',
        'Name' : 'name',
        'NameAutoGenerated' : 'name_autogenerated',
        'Tags' : 'tags'
    }
    # reversed mapping
    internal_to_slicer_alias =  {
        value : key for key, value in slicer_to_internal_alias.items()
    }
    # fields for the __repr__ dunder method
    repr_field_names = ['name', 'label_value', 'color', 'ID']

    def __init__(self, name, color, ID, label_value,
                 extent, color_autogenerated, layer,
                 name_autogenerated, tags) -> None:
        
        self.name = name
        self.color = color
        self.ID = ID
        self.label_value = label_value
        self.extent = extent
        self.color_autogenerated = color_autogenerated
        self.layer = layer
        self.name_autogenerated = name_autogenerated
        self.tags = tags

    
    def __repr__(self) -> str:
        # string repr sequence of selected attributes
        attr_kv_seq = ', '.join(
            ('{}={}'.format(name, getattr(self, name))
            for name in self.repr_field_names)
        )
        repr_str = '{}({})'.format(
            self.__class__.__name__,
            attr_kv_seq
        )
        return repr_str

    
    def __eq__(self, other) -> bool:
        """Dunder comparison method."""
        # TODO: We got to think about the case: When do SegmentInfo
        # objects represent the same thing? When label values are identical?
        # Or when additional fields are equal?
        if not isinstance(other, SegmentInfo):
            return NotImplemented
        else:
            return self.ID == other.ID


    def to_dict(self, keystyle='internal', prefix='') -> Dict:
        """
        Turn/devolve the object into a dictionary (Python primitive).

        Parameters
        ----------

        keystyle : str, optional
            Determines the styling of the keys in the returned dict.
            May be 'internal' (yielding pretty snake_case keys)
            or 'slicer' (yielding ugly CamelCase keys)
            Defaults to 'internal'
        
        prefix : str, optional
            Optional prefix prepended to the keys. Only active for
            'slicer' keystyle. May be used to prepend the Slicer-
            internal 'SegmentN_' to the keys.
            Defaults to '' (empty string)
        
        Returns
        -------

        obj_dict : dict
            The SegmentInfo instance as a Python-primitive
            dictionary
        """
        if keystyle not in ('internal', 'slicer'):
            msg = f'Unrecognized keystyle: {keystyle}'
            raise ValueError(msg)
        
        if keystyle == 'internal':
            obj_dict = {
                key : getattr(self, key)
                for key in self.internal_to_slicer_alias.keys()
            }
        else:
            # Note that for full symmetry we have to back-convert the color float tuple
            # and the extent integer tuple into a space-separated string
            # obj_dict[''.join((prefix, 'Color'))] = ' '.join(str(val) for val in self.color)
            # This is omitted here, probably WeAren'tGonnaNeedIt (WAGNI)
            obj_dict = {
                ''.join((prefix, key)) : getattr(self, value)
                for key, value in self.slicer_to_internal_alias.items()
            }
        return obj_dict


    @property
    def color(self) -> Tuple[float]:
        return self._color
    

    @color.setter
    def color(self, c: Iterable) -> None:
        """
        Set the segment color. Must be a RGB tuple (r, g, b)
        The new color specification may be a space-separated string
        whose parts are required to be float-castable.
        Otherwise a tree tuple is required.
        """
        if isinstance(c, str):
            # try RGB interpretation from string
            c = c.split(' ')
        
        assert len(c) == 3, f'Expecting RGB specification of length 3, got length {len(c)}'
        
        c_checked = []
        for val in c:
            val = float(val)
            assert val >= 0 and val <= 1, 'RGB value must be in closed interval [0, 1]'
            c_checked.append(val)
        
        self._color = tuple(c_checked)


    @property
    def label_value(self) -> int:
        return self._label_value
    

    @label_value.setter
    def label_value(self, new_label_value: int) -> None:
        """
        Managed attribute setter for label_value, which
        is expected to be an integer.
        """
        if not isinstance(new_label_value, int):
            new_label_value = int(new_label_value)
        
        self._label_value = new_label_value


    @property
    def extent(self) -> Union[Tuple, None]:
        return self._extent


    @extent.setter
    def extent(self, extent_candidate: Union[Iterable, None]) -> None:
        """
        Extent setter for managed attribute.
        Tries to cast string as tuple of six integers following the
        3DSlicer API specification:

        SegmentN_Extent: 6 space-separated values
        -> (minI, maxI, minJ, maxJ, minZ, maxZ)
        defining extent of non-empty region within the segment.
        """
        if extent_candidate is None:
            self._extent = None
            return None

        if isinstance(extent_candidate, str):
            extent_candidate = extent_candidate.split(' ')
        
        assert len(extent_candidate) == 6, 'Expecting 6 indices for extent specification in 3D'
        extent = tuple(int(idx) for idx in extent_candidate)
        self._extent = extent
        return None


    @classmethod
    def from_header(cls,
                    header_data: collections.OrderedDict,
                    include_background: bool = True,
                    background_label_value: int = 0) -> List['SegmentInfo']:
        """
        Directly create the exhaustive list of SegmentInfo instances from
        the header data

        Parameters
        ----------

        header_data : dictionary
            Dictionary-like object holding the full information
            about the different segments present in the data.

        include_background : bool, optional
            Set the automatic addition of the segment info
            for the background semantic class that is usually
            not present in a 3DSlicer header_data dict.
            Defaults to True.

        background_label_value : int, optional
            The label value for the background semantic class.
            Noe effect if `include_background = False`
            Must be an integer. Defaults to 0.

        """
        segment_prefix = 'Segment'
        pattern = re.compile(pattern=segment_prefix + '[0-9]+')
        segment_attrs = {}
        # exhaustive search over the full header dictionary
        for key, value in header_data.items():
            # only concern ourselves segment key - value pairs
            if pattern.match(key):
                # 3D Slicer key naming scheme: (SegmentN_attrname, attrval)
                segment_id, attr_alias = key.split('_')
                # translate the 3D Slicer attr alias to our preferred internal name
                attr_name = cls.slicer_to_internal_alias[attr_alias]
                # insert into the dictionary
                try:
                    segment_attrs[segment_id]
                except KeyError:
                    # not encountered this segment up until now
                    # make a new subdictionary
                    segment_attrs[segment_id] = {}
                
                segment_attrs[segment_id][attr_name] = value
        
        segment_infos = [cls(**kwargs) for kwargs in segment_attrs.values()]
        if include_background:
            segment_infos.append(cls.make_background(background_label_value))
        
        return segment_infos
    

    @classmethod
    def make_background(cls, background_label_value) -> 'SegmentInfo':
        """
        Create the default-like background SegmentInfo object.

        Parameters
        ----------

        background_label_value : int
            The label value for the background semantic class,
            Should be an integer.
        """
        if not isinstance(background_label_value, int):
            background_label_value = int(background_label_value)
        return cls(name='background',
                   color=(0, 0, 0),
                   ID='Segment_0',
                   label_value=background_label_value,
                   extent=None,
                   color_autogenerated=0,
                   layer=0,
                   name_autogenerated=0,
                   tags=None)

